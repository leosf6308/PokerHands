---
title: "PokerHand"
author: "Fernando e Leonardo"
date: "01/10/2019"
output: pdf_document
---

# Avaliação

## Introdução

Esse trabalho analisa um `dataset` de mãos de Poker que consistem de 5 cartas. O objetivo é analisar as 5 cartas e estimar qual é a mão para aquele jogo.

## Naïve Bayes

No ramo de Machine Learning, o Naïve Bayes é um grupo de classificadores probabilísticos simples (@wiki1). O algoritmo assume que não há dependência entre as variáveis de entrada, mas que eles dependem de eventos que aconteceram anteriormente. Baseiam-se no teorema de Bayes, que descreve a probablidade de um evento com base nas condições anteriores a esse evento (@wiki2).

O algoritmo Naïve Bayes foi largamente utilizado devido à sua simplicidade @slTing1 

Executa em tempo linear (@REF), em oposição ao tempo 


Fórmula
P (A | B)
Probabilidade de A acontecer se B acontecer antes.

***O que é este Laplace Smoothing nos parâmetros da função
***Esse algoritmo supõe distribuição gaussiana. Isso bate com o dataframe?

## Tipos de mãos do Poker

| Classe | Nome            | Descrição                                                      |
|:------:|-----------------|----------------------------------------------------------------|
| 0      | Carta mais alta | Nenhuma mão de Poker, vence quem possuir a carta mais alta     |
| 1      | Um par          | Duas cartas de mesmo valor                                     |
| 2      | Dois pares      | Dois valores se repetem entre as 5 cartas                      | 
| 3      | Trinca          | Três cartas de valores iguais                                  |
| 4      | Sequência       | 5 cartas em sequência, sem interrupção                         |
| 5      | Flush           | 5 cartas de mesmo naipe                                        |
| 6      | Full House      | Uma trinca e um par na mesma mão                               |
| 7      | Quadra          | 4 cartas de mesmo valor                                        |
| 8      | Straight Flush  | 5 cartas em sequência e do mesmo naipe, sem lacunas            |
| 9      | Royal Flush     | Sequência Dez, Valete, Dama, Rei e Ás, do mesmo naipe          |

A ordem dessa tabela é da mão mais baixa à mão mais alta. A que possui número de classe maior vence sobre as mãos de classe menor.

## Estrutura do Dataset

O dataset PokerHands possui as seguintes colunas:
 1) S1 - Naipe da carta #1: Ordinal (1-4) representando o naipe (Copas, Espadas, Ouros, Paus)
 2) C1 - Valor da carta #1: Numérico (1-13) representando o valor ou número da carta (Ás, 2, 3, ..., 10, Valete, Rainha, Rei)
 3) S2 - Naipe da carta #2: Ordinal (1-4) representando o naipe
 4) C2 - Valor da carta #2: Numérico (1-13) representando o valor
 5) S3 - Naipe da carta #3: Ordinal (1-4) representando o naipe
 6) C3 - Valor da carta #3: Numérico (1-13) representando o valor
 7) S4 - Naipe da carta #4: Ordinal (1-4) representando o naipe
 8) C4 - Valor da carta #4: Numérico (1-13) representando o valor
 9) S5 - Naipe da carta #5: Ordinal (1-4) representando o naipe
10) C5 - Valor da carta #5: Numérico (1-13) representando o valor
11) CLASS - Classificação: Ordinal (0-9) representando a classe que essa mão representa

## Bibliotecas utilizadas

```{r}
library(readr) # Para carregamento do arquivo
library(sqldf) # Para executar SQLs sobre os DataSets
library(e1071) # Contém o algoritmo de Naïve Bayes
library(tidyr) # Para transformar colunas em observações
library(dplyr) # Para operações de seleção, agrupamento
library(ggplot2)
library(data.table) # Para incluir sequencial em grupos
```

## Carregando o arquivo

Leitura do arquivo. Os dados serão lidos como "factors" porquê são variáveis ordinais discretas.
```{r}
pokerTreino <- read_csv("datasets/poker-hand-training-true.data", col_names = c ("S1","C1","S2","C2","S3","C3","S4","C4","S5","C5","CLASS"), col_types = cols(.default = col_factor()))
head(pokerTreino)
```

Leitura do arquivo de teste
```{r}
pokerTeste <- read_csv("datasets/poker-hand-testing.data", col_names = c ("S1","C1","S2","C2","S3","C3","S4","C4","S5","C5","CLASS"), col_types = cols(.default = col_factor()))
head(pokerTeste)
```

## Ajustes
```{r}
pokerTreino$CLASS <- factor(pokerTreino$CLASS, levels=c(0,1,2,3,4,5,6,7,8,9), ordered =TRUE)
pokerTeste$CLASS <- factor(pokerTeste$CLASS, levels=c(0,1,2,3,4,5,6,7,8,9), ordered =TRUE)
```


## Análise do arquivo

```{r}
str(pokerTreino)
```
Sumário do arquivo
```{r}
summary(pokerTreino)
```

## Análise exploratória

Total de linhas nos datasets
```{r}
paste("Linhas no dataset de treino:", nrow(pokerTreino))
paste("Linhas no dataset de teste:", nrow(pokerTeste))
```

Visualização do início do DataSet
```{r}
head(pokerTreino)
```

Divisão dos registros no dataset
```{r}
sqldf('SELECT COUNT(1) AS [Quantidade], 
              class, 
              (CASE WHEN Class = 0 THEN "Nothing"
                   WHEN Class = 1 THEN "One pair"
                   WHEN Class = 2 THEN "Two pairs"
                   WHEN Class = 3 THEN "Three of a kind"
                   WHEN Class = 4 THEN "Straight"
                   WHEN Class = 5 THEN "Flush"
                   WHEN Class = 6 THEN "Full house"
                   WHEN Class = 7 THEN "Four of a kind"
                   WHEN Class = 8 THEN "Straight flush"
                   WHEN Class = 9 THEN "Royal flush" 
              END) AS [TipoENG],
              ROUND(((CAST (COUNT(1) AS real)/(SELECT COUNT(1) FROM pokerTreino)) * 100),2) AS [%]
      FROM pokerTreino 
      GROUP BY class 
      ORDER BY [Quantidade] DESC')
```

Distribuição das classes
```{r}
ggplot(data = pokerTreino, aes(CLASS)) + geom_bar(aes(fill=CLASS))
```

Unica combinação que se repetiu
```{r}
sqldf('SELECT DISTINCT 
              COUNT(1) AS [Quantidade], 
              class, 
              (CASE WHEN Class = 0 THEN "Nothing"
                   WHEN Class = 1 THEN "One pair"
                   WHEN Class = 2 THEN "Two pairs"
                   WHEN Class = 3 THEN "Three of a kind"
                   WHEN Class = 4 THEN "Straight"
                   WHEN Class = 5 THEN "Flush"
                   WHEN Class = 6 THEN "Full house"
                   WHEN Class = 7 THEN "Four of a kind"
                   WHEN Class = 8 THEN "Straight flush"
                   WHEN Class = 9 THEN "Royal flush" 
              END) AS [TipoENG],
              S1,
              C1,
              S2,
              C2,
              S3,
              C3,
              S4,
              C4,
              S5,
              C5
      FROM pokerTreino 
      GROUP BY class, [TipoENG], S1, C1, S2, C2, S3, C3, S4, C4, S5, C5 
      HAVING COUNT(1) > 1
      ORDER BY S1, C1, S2, C2, S3, C3, S4, C4, S5, C5  DESC')
```

Quantidade de linhas onde as combinações são unicas: 25006 de 25010
```{r}
head(sqldf('SELECT DISTINCT 
              COUNT(1) AS [Quantidade], 
              class, 
              (CASE WHEN Class = 0 THEN "Nothing"
                   WHEN Class = 1 THEN "One pair"
                   WHEN Class = 2 THEN "Two pairs"
                   WHEN Class = 3 THEN "Three of a kind"
                   WHEN Class = 4 THEN "Straight"
                   WHEN Class = 5 THEN "Flush"
                   WHEN Class = 6 THEN "Full house"
                   WHEN Class = 7 THEN "Four of a kind"
                   WHEN Class = 8 THEN "Straight flush"
                   WHEN Class = 9 THEN "Royal flush" 
              END) AS [TipoENG],
              S1,
              C1,
              S2,
              C2,
              S3,
              C3,
              S4,
              C4,
              S5,
              C5
      FROM pokerTreino 
      GROUP BY class, [TipoENG], S1, C1, S2, C2, S3, C3, S4, C4, S5, C5 
      HAVING COUNT(1) = 1
      ORDER BY S1, C1, S2, C2, S3, C3, S4, C4, S5, C5  DESC'))
```

Quantidade de números distintos por coluna
```{r}
sqldf('SELECT DISTINCT
       S1,
       C1,
       COUNT(1) AS [Quantidade],
       ROUND(((CAST (COUNT(1) AS real)/(SELECT COUNT(1) FROM pokerTreino)) * 100),2) AS [%]
      FROM pokerTreino 
      GROUP BY S1, C1
      ORDER BY [Quantidade] DESC')
```

Quantidade de números distintos por coluna
```{r}
sqldf('SELECT DISTINCT
       C1,
       S1,
       COUNT(1) AS [Quantidade],
       ROUND(((CAST (COUNT(1) AS real)/(SELECT COUNT(1) FROM pokerTreino)) * 100),2) AS [%]
      FROM pokerTreino 
      GROUP BY C1
      ORDER BY [Quantidade] DESC')
```


## Treinamento

Treinar com o Naïve Bayes
```{r}
pokerTreino <- data.frame(pokerTreino)
resultado <- naiveBayes(pokerTreino[,c("S1","C1","S2","C2","S3","C3","S4","C4","S5","C5")],pokerTreino[,c("CLASS")])
```

Como o algoritmo estruturou seus parâmetros:
```{r}
str(resultado)
```

?
```{r}
resultado$levels
resultado$apriori
```

Estrutura de cada parâmetro
```{r}
for (i in 0:9) {
   print(resultado$tables[i])
}
```

Tentar predizer e verificar com o resultado
```{r}
pokerTeste$resultado_previsto <- predict(resultado, newdata = pokerTeste[1:10], type = "class")
View(pokerTeste)
```

Matriz de confusão
```{r}
matrizConfusao <- table(pokerTeste$resultado_previsto,pokerTeste$CLASS)
matrizConfusao
```

Porcentagem de erros
```{r}
paste("Erro na estimativa durante treino:", sum(as.numeric(pokerTeste$resultado_previsto) != as.numeric(pokerTeste$CLASS)) / nrow(pokerTeste))
```
50% de erro é um valor muito alto. Precisaremos fornecer mais informações para o algoritmo.

Limpeza
```{r}
rm(matrizConfusao)
rm(resultado)
```

## Novas colunas
Incluir colunas para:
- Contagem de cartas iguais
- Contagem de cartas do mesmo naipe
- É sequencial?

```{r}
criarColunas <- function(dataset) {
   dataset$id = seq.int(nrow(dataset))
   #Contagem de naipes
   #transformar os 5 valores da coluna em linhas
   dsGather <- select(dataset,id,S1,S2,S3,S4,S5) %>% gather(key,suit,S1:S5)
   #para cada item, agrupar e pegar o maior
   dsGroup1 <- group_by(select(dsGather,-key),id,suit) %>% summarise(soma = n())
   dsGroup2 <- group_by(dsGroup1,id) %>% summarise(suit = max(soma))
   dataset <- merge(dataset, dsGroup2, by.x = "id", by.y = "id")
   
   #Contagem de valores
   dsGather <- select(dataset,id,C1,C2,C3,C4,C5) %>% gather(key,rank,C1:C5)
   dsGroup1 <- group_by(select(dsGather,-key),id,rank) %>% summarise(soma = n())
   dsGroup2 <- group_by(dsGroup1,id) %>% summarise(rank = max(soma))
   dataset <- merge(dataset, dsGroup2, by.x = "id", by.y = "id")
   
   #Teste de sequencial
   dsGather <- select(dataset,id,C1,C2,C3,C4,C5) %>% gather(key,rank,C1:C5)
   #inserir um sequencial para manter ordenação nos groupBy
   dsGather$rank <- as.numeric(dsGather$rank)
   dsGather <- arrange(dsGather,id,rank) %>% select(id,rank)
   dsGather$pos <- rowid(dsGather$id)
   dsGather$previous <- c(0,dsGather$rank[1:nrow(dsGather)-1])
   #se é o primeiro da lista, não pode ser sequencial
   dsGather$sequential <- ifelse(dsGather$pos == 1,0,dsGather$rank-1 == dsGather$previous)
   #Sequencial especial: 1 e 13. Se existe 1 e 13 para um ID em específico, iremos dizer que o 1 é sequencial
   idsContem1e13 <- intersect(unique(dsGather$id[dsGather$rank==1]),unique(dsGather$id[dsGather$rank==13]))
   dsGather$sequential[dsGather$id %in% idsContem1e13 & dsGather$pos == 1 & dsGather$rank == 1] <- 1
   #dsGather[dsGather$id == 3758 | dsGather$id == 8,]
   #select(dsGather,id,pos,rank,previous,sequential)
   dsGroup1 <- group_by(dsGather,id) %>% summarise(is_sequential = sum(sequential) == 4)
   dataset <- merge(dataset, dsGroup1, by.x = "id", by.y = "id")
   rm(idsContem1e13)
   rm(dsGather)
   rm(dsGroup1)
   rm(dsGroup2)
   #select(pokerTreino,id,C1,C2,C3,C4,C5,is_sequencial)
   dataset <- data.frame(select(dataset,-c(id)))
   return(dataset)
}

pokerTreino <- criarColunas(pokerTreino)
pokerTeste <- criarColunas(pokerTeste)

#Única sequência!
#pokerTreino[pokerTreino$C1 == 9 & pokerTreino$C2 == 10 & pokerTreino$C3 == 11 & pokerTreino$C4 == 12 & pokerTreino$C5 == 13,] %>% select(id,C1,C2,C3,C4,C5,suit,rank,is_sequential,CLASS)
```

Vamos treinar novamente:
```{r}
pokerTreino <- data.frame(pokerTreino)
nv <- naiveBayes(pokerTreino[,c("S1","C1","S2","C2","S3","C3","S4","C4","S5","C5","suit","rank","is_sequential")],pokerTreino[,c("CLASS")])
nv$apriori
```

Novos testes (com a base de treino e a base de teste):
```{r}
pokerTreino$resultado <- predict(nv, newdata = pokerTreino, type = "class")
pokerTeste$resultado <- predict(nv, newdata = pokerTeste, type = "class")
```

Matriz de confusão
```{r}
matrizConfusao <- table(pokerTreino$resultado,pokerTreino$CLASS)
matrizConfusao
matrizConfusao <- table(pokerTeste$resultado,pokerTeste$CLASS)
matrizConfusao
```

Porcentagem de erros.
```{r}
paste("Erro de predição no dataset de treino:", sum(as.numeric(pokerTreino$resultado) != as.numeric(pokerTreino$CLASS)) / nrow(pokerTreino))
paste("Erro de predição no dataset de teste:", sum(as.numeric(pokerTeste$resultado) != as.numeric(pokerTeste$CLASS)) / nrow(pokerTeste))
```
Aproximadamente 6%.

## Fontes

[1] UCI Poker Hand Dataset https://archive.ics.uci.edu/ml/datasets/Poker+Hand

[2] https://www.pokerstars.com/br/poker/games/rules/?no_redirect=1

[3] https://br.pokernews.com/regras-poker/

[]
[] https://en.wikipedia.org/wiki/Bayesian_inference
[] https://en.wikipedia.org/wiki/Bayes%27_theorem
[] https://en.wikipedia.org/wiki/Maximum_likelihood_estimation

@slTing1
S.L. Ting, W.H. Ip, Albert H.C. Tsang "Is Naïve Bayes a Good Classifier for Document Classification?" International Journal of Software Engineering and Its Applications, University, Hung Hum, Kowloon, Hong Kong, 2011

@oracle1
Naive Bayes, Oracle Database Online Documentation Library, 12c Release 1 (12.1.0.2), https://docs.oracle.com/database/121/DMCON/GUID-BB77D68D-3E07-4522-ACB6-FD6723BDA92A.htm#DMCON343, Acesso em 06/10/2019

@wiki1
https://en.wikipedia.org/wiki/Naive_Bayes_classifier, Acesso em 06/10/2019
 
@wiki2
https://en.wikipedia.org/wiki/Bayesian_probability, Acesso em 06/10/2019

@wiki3
https://en.wikipedia.org/wiki/Bayes%27_theorem, Acesso em 06/10/2019

@tds1
https://towardsdatascience.com/bayes-theorem-the-holy-grail-of-data-science-55d93315defb, Acesso em 06/10/2019

@
https://www.mathsisfun.com/data/bayes-theorem.html

https://betterexplained.com/articles/an-intuitive-and-short-explanation-of-bayes-theorem/

https://towardsdatascience.com/naive-bayes-classifier-81d512f50a7c